/*!
 * @pixi/filter-glow - v3.1.1
 * Compiled Fri, 07 Aug 2020 13:37:30 UTC
 *
 * @pixi/filter-glow is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var __filters=function(r,n,o){"use strict";var t="attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}",e="varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nuniform float outerStrength;\r\nuniform float innerStrength;\r\n\r\nuniform vec4 glowColor;\r\n\r\nuniform vec4 filterArea;\r\nuniform vec4 filterClamp;\r\nuniform bool knockout;\r\n\r\nconst float PI = 3.14159265358979323846264;\r\n\r\nconst float DIST = __DIST__;\r\nconst float ANGLE_STEP_SIZE = min(__ANGLE_STEP_SIZE__, PI * 2.0);\r\nconst float ANGLE_STEP_NUM = ceil(PI * 2.0 / ANGLE_STEP_SIZE);\r\n\r\nconst float MAX_TOTAL_ALPHA = ANGLE_STEP_NUM * DIST * (DIST + 1.0) / 2.0;\r\n\r\nvoid main(void) {\r\n    vec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\r\n\r\n    float totalAlpha = 0.0;\r\n\r\n    vec2 direction;\r\n    vec2 displaced;\r\n    vec4 curColor;\r\n\r\n    for (float angle = 0.0; angle < PI * 2.0; angle += ANGLE_STEP_SIZE) {\r\n       direction = vec2(cos(angle), sin(angle)) * px;\r\n\r\n       for (float curDistance = 0.0; curDistance < DIST; curDistance++) {\r\n           displaced = clamp(vTextureCoord + direction * \r\n                   (curDistance + 1.0), filterClamp.xy, filterClamp.zw);\r\n\r\n           curColor = texture2D(uSampler, displaced);\r\n\r\n           totalAlpha += (DIST - curDistance) * curColor.a;\r\n       }\r\n    }\r\n    \r\n    curColor = texture2D(uSampler, vTextureCoord);\r\n\r\n    float alphaRatio = (totalAlpha / MAX_TOTAL_ALPHA);\r\n\r\n    float innerGlowAlpha = (1.0 - alphaRatio) * innerStrength * curColor.a;\r\n    float innerGlowStrength = min(1.0, innerGlowAlpha);\r\n    \r\n    vec4 innerColor = mix(curColor, glowColor, innerGlowStrength);\r\n\r\n    float outerGlowAlpha = alphaRatio * outerStrength * (1. - curColor.a);\r\n    float outerGlowStrength = min(1.0 - innerColor.a, outerGlowAlpha);\r\n\r\n    vec4 outerGlowColor = outerGlowStrength * glowColor.rgba;\r\n    \r\n    if (knockout) {\r\n      float resultAlpha = outerGlowAlpha + innerGlowAlpha;\r\n      gl_FragColor = vec4(glowColor.rgb * resultAlpha, resultAlpha);\r\n    }\r\n    else {\r\n      gl_FragColor = innerColor + outerGlowColor;\r\n    }\r\n}\r\n",i=function(r){function n(o){var i=Object.assign({},n.defaults,o),l=i.distance,a=i.outerStrength,u=i.innerStrength,c=i.color,s=i.knockout,f=i.quality;l=Math.round(l),r.call(this,t,e.replace(/__ANGLE_STEP_SIZE__/gi,""+(1/f/l).toFixed(7)).replace(/__DIST__/gi,l.toFixed(0)+".0")),this.uniforms.glowColor=new Float32Array([0,0,0,1]),Object.assign(this,{color:c,outerStrength:a,innerStrength:u,padding:l,knockout:s})}r&&(n.__proto__=r),n.prototype=Object.create(r&&r.prototype),n.prototype.constructor=n;var i={color:{configurable:!0},outerStrength:{configurable:!0},innerStrength:{configurable:!0},knockout:{configurable:!0}};return i.color.get=function(){return o.rgb2hex(this.uniforms.glowColor)},i.color.set=function(r){o.hex2rgb(r,this.uniforms.glowColor)},i.outerStrength.get=function(){return this.uniforms.outerStrength},i.outerStrength.set=function(r){this.uniforms.outerStrength=r},i.innerStrength.get=function(){return this.uniforms.innerStrength},i.innerStrength.set=function(r){this.uniforms.innerStrength=r},i.knockout.get=function(){return this.uniforms.knockout},i.knockout.set=function(r){this.uniforms.knockout=r},Object.defineProperties(n.prototype,i),n}(n.Filter);return i.defaults={distance:10,outerStrength:4,innerStrength:0,color:16777215,quality:.1,knockout:!1},r.GlowFilter=i,r}({},PIXI,PIXI.utils);Object.assign(PIXI.filters,__filters);
//# sourceMappingURL=filter-glow.js.map
